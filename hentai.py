# meta developer: rain

from .. import loader, utils
from telethon.tl.types import Message
from telethon import Button
from PIL import Image
import aiohttp, time
from io import BytesIO
from dataclasses import dataclass

@dataclass
class Pair:
    first: str
    second: str

    def __iter__(self):
        return iter((self.first, self.second))

class hentai:
    @staticmethod
    def parse_tags(raw: str):
        return [t.strip().lower() for t in raw.replace(",", " ").split() if t.strip()]

    @staticmethod
    async def find_image(tags):
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    "https://api.nekosapi.com/v4/images/random",
                    params={"rating": "explicit", "tags": ",".join(tags), "limit": 1},
                ) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        if isinstance(data, list) and data:
                            image_info = data[0]
                            url = image_info.get("url")
                            tags = image_info.get("tags", [])
                            if url.endswith(".webp"):
                                async with session.get(url) as img_resp:
                                    img_bytes = await img_resp.read()
                                    image = Image.open(BytesIO(img_bytes)).convert("RGBA")
                                    output = BytesIO()
                                    output.name = "image.png"
                                    image.save(output, format="PNG", optimize=True)
                                    output.seek(0)
                                    return output, tags
                            return url, tags
        except Exception as e:
            print(f"[nekosapi error] {e}")
        return None

    @staticmethod
    async def get_pixiv_image(message, max_retries=5):
        async with aiohttp.ClientSession() as session:
            await message.reply("Started search")
            for _ in range(max_retries):
                try:
                    async with session.get("https://api.lolicon.app/setu/v2?r18=1&tag=loli&num=10", proxy="46.61.100.75:7788") as resp:
                        await message.reply(f"Got response with code {resp.status}")
                        if resp.status != 200:
                            continue

                        json_data = await resp.json()
                        data = json_data.get("data", [])
                        for idata in data:
                            tags = idata.get("tags", [])
                            if not any("loli" in tag for tag in tags):
                                continue

                            await message.reply("Got good image")

                            url = idata.get("urls", {}).get("original")
                            if url and await hentai.check_url(session, url):
                                return url
                except Exception as e:
                    print(f"[pixiv api error] {e}")
        return None

    @staticmethod
    async def check_url(session, url: str) -> bool:
        try:
            async with session.head(url) as response:
                return response.status == 200
        except Exception:
            return False

@loader.tds
class HentaiMod(loader.Module):
    """–ú–æ–¥—É–ª—å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ö–µ–Ω—Ç–∞–π –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π"""

    strings = {
        "name": "HentaiMod",
        "lang": "EN",
        "looking_for": "{} Searching for an image by tags:",
        "no_tags": "{} Provide at least one tag. Example: <code>.hentai pussy</code>",
        "not_found": "{} Nothing found by tags:",
        "more": "{} More",
        "tags": "{} Tags:"
    }

    strings_ru = {
        "lang": "RU",
        "looking_for": "{} –ò—â—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ —Ç–µ–≥–∞–º:",
        "no_tags": "{} –£–∫–∞–∂–∏ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Ç–µ–≥. –ü—Ä–∏–º–µ—Ä: <code>.hentai pussy</code>",
        "not_found": "{} –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ —Ç–µ–≥–∞–º:",
        "more": "{} –ï—â—ë",
        "tags": "{} <b>–¢–µ–≥–∏:</b>"
    }

    format_map = {
        "looking_for": Pair("üîé", "<emoji document_id=5231012545799666522>üîç</emoji>"),
        "no_tags": Pair("‚ùå", "<emoji document_id=5210952531676504517>‚ùå</emoji>"),
        "not_found": Pair("‚ö†Ô∏è", "<emoji document_id=5447644880824181073>‚ö†Ô∏è</emoji>"),
        "more": Pair("üîÅ", "üîÅ"),
        "tags": Pair("#Ô∏è‚É£", "<emoji document_id=5305265301917549162>üìé</emoji>")
    }

    def format_string(self, string_name: str):
        string = self.strings(string_name)
        e1, e2 = self.format_map[string_name]
        if self._client.hikka_me.premium:
            return string.format(e2)
        else:
            return string.format(e1)

    genres_en = ["anal", "beach", "bikini", "black hair", "blonde hair", "blue hair", "boy", "brown hair", "bunny girl", "catgirl", "dick", "dress", "exposed anus", "exposed girl breasts", "flat chest", "flowers", "futanari", "girl", "glasses", "gloves", "guitar", "horsegirl", "ice cream", "kemonomimi", "kissing", "large breasts", "maid", "masturbating", "medium breasts", "mountain", "night", "pink hair", "plants", "purple hair", "pussy", "rain", "reading", "red hair", "school uniform", "shorts", "skirt", "small breasts", "sportswear", "sunny", "sword", "threesome", "tree", "usagimimi", "weapon", "wet", "white hair", "yuri"]
    genres_ru = ["–∞–Ω–∞–ª", "–ø–ª—è–∂", "–±–∏–∫–∏–Ω–∏", "—á—ë—Ä–Ω—ã–µ –≤–æ–ª–æ—Å—ã", "—Å–≤–µ—Ç–ª—ã–µ –≤–æ–ª–æ—Å—ã", "–≥–æ–ª—É–±—ã–µ –≤–æ–ª–æ—Å—ã", "–ø–∞—Ä–µ–Ω—å", "–∫–æ—Ä–∏—á–Ω–µ–≤—ã–µ –≤–æ–ª–æ—Å—ã", "–¥–µ–≤—É—à–∫–∞-–∫—Ä–æ–ª–∏–∫", "–¥–µ–≤—É—à–∫–∞-–∫–æ—à–∫–∞", "–ø–µ–Ω–∏—Å", "–æ–¥–µ–∂–¥–∞", "–æ–±–Ω–∞–∂–µ–Ω–Ω—ã–π –∞–Ω—É—Å", "–æ–±–Ω–∞–∂–µ–Ω–Ω–∞—è –∂–µ–Ω—Å–∫–∞—è –≥—Ä—É–¥—å", "–ø–ª–æ—Å–∫–∞—è –≥—Ä—É–¥—å", "—Ü–≤–µ—Ç—ã", "–≥–µ—Ä–º–∞—Ñ—Ä–æ–¥–∏—Ç", "–¥–µ–≤—É—à–∫–∞", "–æ—á–∫–∏", "–ø–µ—Ä—á–∞—Ç–∫–∏", "–≥–∏—Ç–∞—Ä–∞", "–¥–µ–≤—É—à–∫–∞-–ª–æ—à–∞–¥—å", "–º–æ—Ä–æ–∂–µ–Ω–æ–µ", "–∫–µ–º–æ–Ω–æ–º–∏–º–∏", "–ø–æ—Ü–µ–ª—É–π", "–±–æ–ª—å—à–∞—è –≥—Ä—É–¥—å", "—Å–ª—É–∂–∞–Ω–∫–∞", "–º–∞—Å—Ç—É—Ä–±–∏—Ä–æ–≤–∞—Ü–∏—è", "—Å—Ä–µ–¥–Ω—è—è –≥—Ä—É–¥—å", "–≥–æ—Ä–∞", "–Ω–æ—á—å", "—Ä–æ–∑–æ–≤—ã–µ –≤–æ–ª–æ—Å—ã", "—Ä–∞—Å—Ç–µ–Ω–∏—è", "—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–µ –≤–æ–ª–æ—Å—ã", "–∫–∏—Å–∫–∞", "–¥–æ–∂–¥—å", "—á—Ç–µ–Ω–∏–µ", "–∫—Ä–∞—Å–Ω—ã–µ –≤–æ–ª–æ—Å—ã", "—à–∫–æ–ª—å–Ω–∞—è —Ñ–æ—Ä–º–∞", "—à–æ—Ä—Ç—ã", "—é–±–∫–∞", "–º–∞–ª–µ–Ω—å–∫–∞—è –≥—Ä—É–¥—å", "—Å–ø–æ—Ä—Ç–∏–≤–Ω–∞—è –æ–¥–µ–∂–¥–∞", "—Å–æ–ª–Ω–µ—á–Ω–æ", "–º–µ—á", "—Ç—Ä–æ–π–∫–∞", "–¥–µ—Ä–µ–≤–æ", "—É—Å–∞–≥–∏–º–∏–º–∏", "–æ—Ä—É–∂–∏–µ", "–º–æ–∫—Ä–æ–µ —Ç–µ–ª–æ", "–±–µ–ª—ã–µ –≤–æ–ª–æ—Å—ã", "—é—Ä–∏"]

    def translate_tags(self, tags):
        lang = self.strings("lang")
        translation_map = dict(zip(self.genres_en, self.genres_ru)) if lang == "RU" else {}
        return ', '.join(f"<code>{translation_map.get(tag, tag).replace('_', ' ')}</code>" for tag in tags)

    @loader.command(ru_doc="–ü–æ–∏—Å–∫ –ø–æ —Ç–µ–≥–∞–º", en_doc="Search by tags")
    async def hentai(self, message: Message):
        raw = utils.get_args_raw(message)
        if not raw:
            await message.edit(self.format_string("no_tags"), parse_mode="html")
            return

        tags = hentai.parse_tags(raw)
        await message.edit(f"{self.format_string('looking_for')} <code>{', '.join(tags)}</code>...", parse_mode="html")

        result = await hentai.find_image(tags)
        if not result:
            await message.edit(f"{self.format_string('not_found')} <code>{', '.join(tags)}</code>.", parse_mode="html")
            return

        file, found_tags = result
        caption = f"{self.format_string('tags')} {self.translate_tags(found_tags)}"
        btns = [[Button.inline(self.format_string("more"), data="hentai:" + ",".join(tags))]]

        await message.client.send_file(
            message.chat_id,
            file,
            caption=caption,
            reply_to=message.reply_to_msg_id,
            buttons=btns,
            parse_mode="html"
        )
        await message.delete()

    async def inline__hentai(self, call, args):
        if not args:
            await call.answer(self.format_string("no_tags"), alert=True)
            return

        tags = args[0].split(",")
        result = await hentai.find_image(tags)
        if not result:
            await call.answer(self.format_string("not_found"), alert=True)
            return

        file, found_tags = result
        caption = f"{self.format_string('tags')} {self.translate_tags(found_tags)}"
        btns = [[Button.inline(self.format_string("more"), data="hentai:" + ",".join(tags))]]

        await call.edit(file=file, text=caption, buttons=btns, parse_mode="html")
    
    @loader.command(ru_doc="–°–ª—É—á–∞–π–Ω–æ–µ —Ö–µ–Ω—Ç–∞–π –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (Pixiv)", en_doc="Random hentai image (Pixiv)")
    async def loli(self, message: Message):
        await message.edit(self.format_string("looking_for") + " ...", parse_mode="html")

        result = await hentai.get_pixiv_image(message)
        if not result:
            await message.edit(self.format_string("not_found") + ".", parse_mode="html")
            return

        url = result
        caption = f"{self.format_string('tags')} {self.translate_tags(found_tags)}"

        await message.client.send_file(
            message.chat_id,
            url,
            caption=caption,
            reply_to=message.reply_to_msg_id,
            parse_mode="html"
        )
        await message.delete()